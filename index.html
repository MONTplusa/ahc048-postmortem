<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ‡ãƒãƒƒã‚°ãƒ‡ãƒ¼ã‚¿å¯è¦–åŒ–</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 0;
        }

        #controls {
            padding: 10px;
            background: #222;
            color: #fff;
            text-align: center;
        }

        #controls button {
            margin: 0 5px;
            padding: 5px 10px;
            font-size: 14px;
        }

        #phaseLabel {
            margin: 10px;
            text-align: center;
        }

        #container {
            display: flex;
            height: calc(100vh - 80px);
        }

        /* ã‚³ãƒ¡ãƒ³ãƒˆé ˜åŸŸã‚’åºƒã‚ã«ã€11px ãƒ•ã‚©ãƒ³ãƒˆã€è¡Œé–“ã‚¼ãƒ­ */
        #comments {
            width: 60%;
            padding: 16px;
            box-sizing: border-box;
            overflow-y: auto;
            background: #fff;
            border-left: 1px solid #ccc;
            font-size: 11px;
        }

        #comments p {
            margin: 0;
            word-break: break-word;
        }

        /* ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«é ˜åŸŸ */
        #visualization {
            width: 40%;
            padding: 16px;
            box-sizing: border-box;
            overflow-y: auto;
            background: #f0f0f0;
        }

        .visualizer-title {
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: bold;
            color: #000;
        }

        .main-value {
            margin-bottom: 14px;
            font-size: 14px;
            font-weight: bold;
            color: #000;
        }

        /* sub è¡¨ç¤ºãƒ©ãƒƒãƒ‘ãƒ¼ */
        .bar-wrapper {
            margin-bottom: 12px;
        }

        .amountCMY {
            font-size: 11px;
            margin-bottom: 2px;
        }

        .row {
            display: flex;
            align-items: center;
        }

        .item {
            height: 30px;
            border-radius: 4px;
            border: 2px solid #000;
        }

        .size-label {
            font-size: 12px;
            margin-left: 4px;
            min-width: 60px;
        }

        .keyword {
            font-weight: bold;
            color: #d00;
        }

        /* ãƒ¬ã‚·ãƒ”ã‚¹ãƒ†ãƒƒãƒ—ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ */
        .recipe-visualizer {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fff;
            padding: 16px;
        }

        .recipe-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 16px;
            text-align: center;
        }

        .recipe-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
        }

        .recipe-controls button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .recipe-controls .prev-btn {
            background: #666;
            color: white;
        }

        .recipe-controls .next-btn {
            background: #333;
            color: white;
        }

        .recipe-controls button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .recipe-step {
            margin-bottom: 16px;
        }

        .step-header {
            font-weight: bold;
            color: #495057;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .step-content {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 4px;
            border-left: 4px solid #333;
        }

        .step-visual {
            display: flex;
            align-items: center;
            margin: 8px 0;
            gap: 8px;
        }

        .step-bar {
            height: 20px;
            border: 1px solid #333;
            border-radius: 2px;
            background: #ddd;
            position: relative;
            min-width: 60px;
        }

        .step-bar-fill {
            height: 100%;
            border-radius: 1px;
            transition: width 0.3s ease;
        }

        .step-arrow {
            font-size: 18px;
            color: #333;
        }

        .step-text {
            font-size: 12px;
            color: #666;
        }

        .recipe-result {
            background: #e9ecef;
            padding: 12px;
            border-radius: 4px;
            margin-top: 12px;
            font-weight: bold;
        }

        /* æ–°ã—ã„ãƒ¬ã‚·ãƒ”ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .recipe-state-visualizer {
            margin-bottom: 20px;
        }

        .sub-container {
            margin-bottom: 16px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fff;
        }

        .sub-header {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
            color: #333;
        }

        .sub-visual {
            position: relative;
            height: 40px;
            border-radius: 4px;
            overflow: hidden;
            border: 2px solid #000;
            margin-bottom: 8px;
        }

        .paint-canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .paint-section {
            display: flex;
            flex: 1;
        }

        .paint-area {
            border-right: 2px solid #000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
        }

        .paint-area:last-child {
            border-right: none;
        }

        .keep-divider {
            border-left: 3px solid #ff6b35;
        }

        .mixed-result {
            width: 50px;
            border-left: 3px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
        }

        .sub-info {
            font-size: 11px;
            color: #666;
            display: flex;
            justify-content: space-between;
        }

        /* è‰²ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
        .color-preview-section {
            margin-top: 20px;
            padding: 16px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fff;
        }

        .color-preview-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 12px;
            color: #333;
        }

        .color-comparison {
            display: flex;
            gap: 16px;
            margin-bottom: 12px;
        }

        .color-sample {
            flex: 1;
            text-align: center;
        }

        .color-sample-title {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 4px;
            color: #666;
        }

        .color-box {
            width: 100%;
            height: 60px;
            border: 2px solid #000;
            border-radius: 4px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
        }

        .color-info {
            font-size: 10px;
            color: #666;
            line-height: 1.2;
        }

        .error-display {
            text-align: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #dc3545;
        }

        .error-value {
            font-size: 14px;
            font-weight: bold;
            color: #dc3545;
        }

        .error-label {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
        }
    </style>
</head>

<body>
    <div id="controls">
        <button id="firstBtn">é–‹å§‹å‰å‡¦ç†ã¸</button>
        <button id="prevBtn">å‰ã¸</button>
        <button id="nextBtn">æ¬¡ã¸</button>
        <button id="lastBtn">æœ€çµ‚å‡¦ç†ã¸</button>
    </div>
    <h2 id="phaseLabel"></h2>
    <div id="container">
        <div id="visualization"></div>
        <div id="comments"></div>
    </div>

    <script>
        let phases = [];
        let current = 0;
        let globalMax = 100; // åˆæœŸå€¤ã€‚é–‹å§‹å‰å‡¦ç†ã§ç½®ãæ›ãˆã€‚

        /* æ–°ã—ã„Stateç®¡ç†æ§‹é€  */
        class Area {
            constructor(size = 0, amount = 0) {
                this.size = size;
                this.amount = amount;
            }

            get density() {
                return this.size > 0 ? this.amount / this.size : 0;
            }

            get opacity() {
                // å¯†åº¦ã«å¿œã˜ã¦æ¿ƒã•ã¨è–„ã•ã‚’æ€¥æ¿€ã«å¤‰åŒ–ã•ã›ã‚‹ï¼ˆ0.3ä¹—ï¼‰
                // 0.01 â†’ 0.22, 0.04 â†’ 0.34, 0.25 â†’ 0.63, 1.0 â†’ 1.0
                const adjustedOpacity = Math.pow(this.density, 0.3);
                return Math.min(1.0, Math.max(0.0, adjustedOpacity));
            }
        }

        class SubState {
            constructor(id, color, maxSize = 95) {
                this.id = id;
                this.color = color;
                this.maxSize = maxSize;
                this.keeps = []; // ã‚­ãƒ¼ãƒ—ã‚¨ãƒªã‚¢é…åˆ—
                this.current = new Area(); // ç¾åœ¨ã®ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢
                this.room = null; // æ‹¡å¼µæ™‚ã®ä¸€æ™‚ã‚¨ãƒªã‚¢
                this.pending = null; // æ’å‡ºå¾…ã¡ã‚¨ãƒªã‚¢
                this.empty = new Area(); // ç©ºã‚¨ãƒªã‚¢
            }

            get totalSize() {
                const keepsSize = this.keeps.reduce((sum, keep) => sum + keep.size, 0);
                const currentSize = this.current.size;
                const roomSize = this.room ? this.room.size : 0;
                const pendingSize = this.pending ? this.pending.size : 0;
                return keepsSize + currentSize + roomSize + pendingSize;
            }

            updateEmpty() {
                this.empty.size = this.maxSize - this.totalSize;
                this.empty.amount = 0;
            }
        }

        class State {
            constructor(stepIndex = 0, hint = '', message = '') {
                this.stepIndex = stepIndex;
                this.subs = [];
                this.hint = hint;
                this.message = message;
                this.submittedColors = []; // æ’å‡ºæ¸ˆã¿è‰²å±¥æ­´ã‚’Stateã«å«ã‚ã‚‹
            }
        }

        let allStates = []; // å…¨ã‚¹ãƒ†ãƒƒãƒ—ã®çŠ¶æ…‹é…åˆ—
        let currentStateIndex = 0;
        let recipeSteps = [];
        let baseColors = []; // å„subã®åŸºæœ¬è‰²

        fetch('./data.txt')
            .then(res => res.text())
            .then(rawData => {
                const parts = rawData.split(/-----\s*(.*?)\s*-----/g).slice(1);
                for (let i = 0; i < parts.length; i += 2) {
                    phases.push({ label: parts[i], body: parts[i + 1].trim() });
                }
                // é–‹å§‹å‰å‡¦ç†ã‚³ãƒ¡ãƒ³ãƒˆã‹ã‚‰æœ€å¤§å€¤ã¨Kå€¤ã‚’å–å¾—
                const start = phases.find(p => /é–‹å§‹å‰å‡¦ç†/.test(p.label));
                if (start) {
                    const m = start.body.match(/æœ€å¤§ã¯\s*(\d+)\s*ãƒã‚¹/);
                    if (m) globalMax = parseInt(m[1]);

                    // Kå€¤ï¼ˆè‰²æ•°ï¼‰ã‚’å–å¾—ã—ã¦åŸºæœ¬è‰²ã‚’ç”Ÿæˆ
                    const kMatch = start.body.match(/K\s*=\s*(\d+)/);
                    if (kMatch) {
                        const colorCount = parseInt(kMatch[1]);
                        baseColors = generateBaseColors(colorCount);
                    }
                }
                render();
            });

        /* CMY -> RGB */
        function cmyToRgb(c, m, y) {
            const r = Math.round((1 - c) * 255);
            const g = Math.round((1 - m) * 255);
            const b = Math.round((1 - y) * 255);
            return [r, g, b];
        }
        /* èƒŒæ™¯ã«åˆã‚ã›ãŸãƒ†ã‚­ã‚¹ãƒˆè‰² */
        function textColorForBg(r, g, b) {
            const brightness = r * 0.299 + g * 0.587 + b * 0.114;
            return brightness < 128 ? '#fff' : '#000';
        }

        /* åŸºæœ¬è‰²ã®ç”Ÿæˆ */
        function generateBaseColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = (i * 360 / count) % 360;
                colors.push(`hsl(${hue}, 70%, 60%)`);
            }
            return colors;
        }


        /* ãƒ¬ã‚·ãƒ”è§£æï¼ˆäºŒæ®µéšä»•åˆ‡ã‚Šå¯¾å¿œï¼‰ */
        function parseRecipe(bodyText) {
            const lines = bodyText.split('\n');
            const recipeStart = lines.findIndex(l => l.includes('ã€‡æœ€é©ãªãƒ¬ã‚·ãƒ”'));
            if (recipeStart === -1) return [];

            const recipeLines = lines.slice(recipeStart);
            const steps = [];
            let currentSub = null;
            let currentSteps = [];

            for (const line of recipeLines) {
                const trimmed = line.trim();
                if (trimmed.startsWith('# sub') && trimmed.includes('ã®ãƒ¬ã‚·ãƒ”')) {
                    // å‰ã®subã®å‡¦ç†ã‚’å®Œäº†
                    if (currentSub) {
                        steps.push({
                            sub: currentSub,
                            steps: [...currentSteps]
                        });
                    }
                    // æ–°ã—ã„subã®é–‹å§‹
                    const subMatch = trimmed.match(/sub(\d+)/);
                    const targetMatch = trimmed.match(/ç›®æ¨™èª¿åˆæ¯”\s*([0-9.]+)/);
                    currentSub = {
                        id: subMatch ? parseInt(subMatch[1]) : 0,
                        target: targetMatch ? parseFloat(targetMatch[1]) : 0
                    };
                    currentSteps = [];
                } else if (trimmed.startsWith('# ãƒ»') && currentSub) {
                    // ã‚¹ãƒ†ãƒƒãƒ—ã®è¿½åŠ ï¼ˆäºŒæ®µéšåŒ–ï¼‰
                    const stepText = trimmed.replace('# ãƒ»', '');

                    // ã‚­ãƒ¼ãƒ—å‡¦ç†ï¼ˆä»•åˆ‡ã‚Šè¨­ç½®ã®ã¿ï¼‰
                    if (stepText.includes('ãƒã‚¹ã‚’ã‚­ãƒ¼ãƒ—')) {
                        const keepMatch = stepText.match(/(\d+)ãƒã‚¹ã‚’ã‚­ãƒ¼ãƒ—/);
                        if (keepMatch) {
                            currentSteps.push(`ã‚­ãƒ¼ãƒ—ç”¨ä»•åˆ‡ã‚Šã‚’è¨­ç½®ã—ã¦ã‚­ãƒ¼ãƒ—é ˜åŸŸã‚’ç¢ºä¿`);
                        }
                    }
                    // æ‹¡å¼µå‡¦ç†ã‚’è©³ç´°ã«åˆ†ã‘ã‚‹
                    else if (stepText.includes('ãƒã‚¹æ‹¡å¼µ')) {
                        const expandMatch = stepText.match(/(\d+)ãƒã‚¹æ‹¡å¼µ.*?(\d+)ãƒã‚¹ã«/);
                        if (expandMatch) {
                            const expandSize = expandMatch[1];
                            const newSize = expandMatch[2];
                            currentSteps.push(`æ‹¡å¼µå…ˆã«æ–°ã—ã„ä»•åˆ‡ã‚Šã‚’è¨­ç½®`);
                            currentSteps.push(`å…ƒã®ä»•åˆ‡ã‚Šã‚’è§£é™¤ã—ã¦ã‚¤ãƒ³ã‚¯ãŒ${expandSize}ãƒã‚¹åˆ†æµã‚Œè¾¼ã¿${newSize}ãƒã‚¹ã«æ‹¡å¼µï¼ˆè‰²ãŒè–„ããªã‚‹ï¼‰`);
                        }
                    }
                    // å–ã‚Šå‡ºã—å‡¦ç†ï¼ˆä»•åˆ‡ã‚Šè¨­ç½®ã¨æ’å‡ºã‚’åˆ†é›¢ï¼‰
                    else if (stepText.includes('ãƒã‚¹å–ã‚Š')) {
                        const takeMatch = stepText.match(/(\d+)ãƒã‚¹å–ã‚Š/);
                        if (takeMatch) {
                            const takeSize = takeMatch[1];
                            currentSteps.push(`å³ã‹ã‚‰${takeSize}ãƒã‚¹ä½ç½®ã«ä»•åˆ‡ã‚Šã‚’è¨­ç½®`);
                            currentSteps.push(`ä»•åˆ‡ã‚Šè§£é™¤ã—ã¦ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ã«æ’å‡º`);
                        }
                    }
                    // ãã®ä»–ã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ãã®ã¾ã¾
                    else {
                        currentSteps.push(stepText);
                    }
                } else if (trimmed.startsWith('# ä»¥ä¸Šã«ã‚ˆã‚Š') && currentSub) {
                    // çµæœã®è¿½åŠ ï¼ˆè¨ˆç®—èª¬æ˜ãªã®ã§ã‚¹ãƒ†ãƒƒãƒ—ã«ã¯å«ã‚ãªã„ï¼‰
                    // const resultText = trimmed.replace('# ', '');
                    // currentSteps.push(resultText);
                } else if (trimmed.startsWith('# èª¿åˆæ¯”') && currentSub) {
                    // æœ€çµ‚èª¿åˆæ¯”
                    const ratioMatch = trimmed.match(/èª¿åˆæ¯”\s*=\s*([0-9.]+)/);
                    if (ratioMatch) {
                        currentSub.finalRatio = parseFloat(ratioMatch[1]);
                    }
                }
            }

            // æœ€å¾Œã®subã®å‡¦ç†
            if (currentSub) {
                steps.push({
                    sub: currentSub,
                    steps: [...currentSteps]
                });
            }

            return steps;
        }

        /* ãƒ¬ã‚·ãƒ”ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ã®ä½œæˆ */
        function createRecipeVisualizer() {
            const viz = document.getElementById('visualization');

            // ç¾åœ¨ã®ãƒ•ã‚§ãƒ¼ã‚ºã®subãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const lines = phases[current].body.split('\n');
            const subLines = lines.filter(l => /^\[sub\d+\]/.test(l));

            const recipeDiv = document.createElement('div');
            recipeDiv.className = 'recipe-visualizer';
            recipeDiv.innerHTML = `
                <div class="recipe-title">æœ€é©ãªãƒ¬ã‚·ãƒ” - ã‚¹ãƒ†ãƒƒãƒ—ãƒã‚¤ã‚¹ãƒ†ãƒƒãƒ—</div>
                <div class="recipe-controls">
                    <button class="prev-btn" onclick="prevRecipeStep()">â† å‰ã®ã‚¹ãƒ†ãƒƒãƒ—</button>
                    <span id="recipeStepCounter">1 / 1</span>
                    <button class="next-btn" onclick="nextRecipeStep()">æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ— â†’</button>
                </div>
                <div class="recipe-state-visualizer"></div>
                <div id="recipeStepContent"></div>
            `;

            viz.appendChild(recipeDiv);

            // å¼·åˆ¶çš„ã«sub-containerã‚’ä½œæˆ
            const stateViz = recipeDiv.querySelector('.recipe-state-visualizer');
            subLines.forEach((line, index) => {
                const size = parseInt(line.match(/size:\s*(\d+)/)[1]);
                const container = document.createElement('div');
                container.className = 'sub-container';

                const header = document.createElement('div');
                header.textContent = `sub${index}`;

                const paintSection = document.createElement('div');
                paintSection.className = 'paint-section';
                paintSection.style.width = '100%';
                paintSection.style.height = '40px';
                paintSection.style.border = '1px solid #ccc';
                paintSection.style.position = 'relative';

                container.appendChild(header);
                container.appendChild(paintSection);
                stateViz.appendChild(container);
            });

            console.log('sub-containers created:', document.querySelectorAll('.sub-container').length);
        }

        /* å„subã®çŠ¶æ…‹å¯è¦–åŒ–ã‚’ä½œæˆ */
        function createStateVisualization(subLines) {
            const stateViz = document.querySelector('.recipe-state-visualizer');
            console.log('createStateVisualizationé–‹å§‹, stateViz:', stateViz);
            console.log('subLines:', subLines);

            // å„subã®çŠ¶æ…‹ã‚’åˆæœŸåŒ–
            initializeSubStates(subLines);

            subLines.forEach((line, index) => {
                const size = parseInt(line.match(/size:\s*(\d+)/)[1]);
                const amount = parseFloat(line.match(/amount:\s*([0-9.]+)/)[1]);
                const cmyMatch = line.match(/CMY:\s*\[([0-9eE+\-.]+) ([0-9eE+\-.]+) ([0-9eE+\-.]+)\]/);
                const c = parseFloat(cmyMatch[1]);
                const m = parseFloat(cmyMatch[2]);
                const y = parseFloat(cmyMatch[3]);
                const [r, g, b] = cmyToRgb(c, m, y);

                const container = document.createElement('div');
                container.className = 'sub-container';

                const header = document.createElement('div');
                header.className = 'sub-header';
                header.textContent = `sub${index} (size: ${size})`;

                const visual = document.createElement('div');
                visual.className = 'sub-visual';

                // DOMè¦ç´ ã§æç”»ï¼ˆCanvaså•é¡Œã‚’å›é¿ï¼‰
                const paintSection = document.createElement('div');
                paintSection.className = 'paint-section';
                paintSection.style.position = 'relative';
                paintSection.style.width = '100%';
                paintSection.style.height = '40px';
                paintSection.style.display = 'flex';
                paintSection.id = `paint-sub${index}`;

                visual.appendChild(paintSection);

                // åˆæœŸçŠ¶æ…‹ã‚’æç”»
                // æ—§ã‚·ã‚¹ãƒ†ãƒ  - æ–°ã‚·ã‚¹ãƒ†ãƒ ã§ç½®ãæ›ãˆæ¸ˆã¿
                console.log('æ—§drawSubStateDOMå‘¼ã³å‡ºã—ã‚’ã‚¹ã‚­ãƒƒãƒ—');

                // å³å´ï¼šèª¿åˆçµæœï¼ˆå¾Œã§ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã«æ›´æ–°ï¼‰
                const mixedResult = document.createElement('div');
                mixedResult.className = 'mixed-result';
                mixedResult.style.backgroundColor = '#ddd';
                mixedResult.textContent = '?';
                visual.appendChild(mixedResult);

                const info = document.createElement('div');
                info.className = 'sub-info';
                info.innerHTML = `
                    <span>amount: ${amount.toFixed(3)}</span>
                    <span>CMY: [${c.toFixed(3)} ${m.toFixed(3)} ${y.toFixed(3)}]</span>
                `;

                container.appendChild(header);
                container.appendChild(visual);
                container.appendChild(info);
                stateViz.appendChild(container);
            });
        }

        /* æ–°ã—ã„ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–¢æ•° */
        function renderArea(area, type, color, maxSize) {
            const div = document.createElement('div');
            div.className = 'area-section';
            div.style.height = '100%';
            div.style.display = 'flex';
            div.style.alignItems = 'center';
            div.style.justifyContent = 'center';
            div.style.fontSize = '10px';
            div.style.fontWeight = 'bold';
            div.style.borderRight = '2px solid #000';
            div.style.width = `${(area.size / maxSize) * 100}%`;
            div.style.boxSizing = 'border-box'; // å¢ƒç•Œç·šã‚’å†…å´ã«å«ã‚ã‚‹

            const opacity = area.opacity;
            let bgColor, textColor, label;

            switch (type) {
                case 'keep':
                    const keepRgb = hexToRgb(color);
                    bgColor = `rgba(${keepRgb.r}, ${keepRgb.g}, ${keepRgb.b}, ${opacity})`;
                    textColor = '#000';
                    label = area.size > 2 ? `Keep:${area.size}` : '';
                    break;
                case 'current':
                    const rgb = hexToRgb(color);
                    bgColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                    textColor = '#000';
                    label = area.size > 2 ? `Use:${area.size}` : '';
                    break;
                case 'room':
                    const roomRgb = hexToRgb(color);
                    bgColor = `rgba(${roomRgb.r}, ${roomRgb.g}, ${roomRgb.b}, ${opacity})`;
                    textColor = '#000';
                    label = area.size > 2 ? `+${area.size}` : '';
                    break;
                case 'pending':
                    const pendingRgb = hexToRgb(color);
                    bgColor = `rgba(${pendingRgb.r}, ${pendingRgb.g}, ${pendingRgb.b}, ${opacity})`;
                    textColor = '#000';
                    label = area.size > 2 ? `Take:${area.size}` : '';
                    break;
                case 'empty':
                    const emptyRgb = hexToRgb(color);
                    bgColor = `rgba(${emptyRgb.r}, ${emptyRgb.g}, ${emptyRgb.b}, ${opacity})`;
                    textColor = '#000';
                    label = area.size > 2 ? `Empty:${area.size}` : '';
                    break;
                default:
                    bgColor = '#ddd';
                    textColor = '#333';
                    label = '';
            }

            div.style.backgroundColor = bgColor;
            div.style.color = textColor;
            div.style.textShadow = 'none';
            div.textContent = label;

            // keepã‚¨ãƒªã‚¢ã«ã¯æ–œç·šãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¿½åŠ 
            if (type === 'keep') {
                div.style.backgroundImage = 'repeating-linear-gradient(45deg, transparent, transparent 3px, rgba(255,255,255,0.3) 3px, rgba(255,255,255,0.3) 6px)';
            }

            return div;
        }

        function renderSubState(subState) {
            const container = document.createElement('div');
            container.className = 'sub-state-container';
            container.style.display = 'flex';
            container.style.height = '100%';
            container.style.width = '100%';
            container.style.position = 'relative';

            // ã‚­ãƒ¼ãƒ—ã‚¨ãƒªã‚¢ã‚’è¿½åŠ 
            subState.keeps.forEach(keep => {
                container.appendChild(renderArea(keep, 'keep', subState.color, subState.maxSize));
            });

            // ç¾åœ¨ã‚¨ãƒªã‚¢ã‚’è¿½åŠ 
            if (subState.current.size > 0) {
                container.appendChild(renderArea(subState.current, 'current', subState.color, subState.maxSize));
            }

            // æ‹¡å¼µã‚¨ãƒªã‚¢ã‚’è¿½åŠ 
            if (subState.room && subState.room.size > 0) {
                container.appendChild(renderArea(subState.room, 'room', subState.color, subState.maxSize));
            }

            // æ’å‡ºå¾…ã¡ã‚¨ãƒªã‚¢ã‚’è¿½åŠ 
            if (subState.pending && subState.pending.size > 0) {
                container.appendChild(renderArea(subState.pending, 'pending', subState.color, subState.maxSize));
            }

            // ç©ºã‚¨ãƒªã‚¢ã‚’è¿½åŠ 
            if (subState.empty.size > 0) {
                container.appendChild(renderArea(subState.empty, 'empty', subState.color, subState.maxSize));
            }

            // æœ€å¾Œã®å¢ƒç•Œç·šã‚’å‰Šé™¤
            if (container.lastChild) {
                container.lastChild.style.borderRight = 'none';
            }

            // ã‚µã‚¤ã‚ºæƒ…å ±
            const totalAmount = subState.keeps.reduce((sum, keep) => sum + keep.amount, 0) + subState.current.amount + (subState.room?.amount || 0);
            const totalSize = subState.totalSize;
            const avgDensity = totalSize > 0 ? (totalAmount / totalSize).toFixed(3) : '0.000';

            const sizeInfo = document.createElement('div');
            sizeInfo.style.position = 'absolute';
            sizeInfo.style.bottom = '2px';
            sizeInfo.style.left = '4px';
            sizeInfo.style.fontSize = '9px';
            sizeInfo.style.color = '#666';
            sizeInfo.style.backgroundColor = 'rgba(255,255,255,0.8)';
            sizeInfo.style.padding = '1px 3px';
            sizeInfo.style.borderRadius = '2px';
            sizeInfo.textContent = `${totalSize}/${subState.maxSize} (${totalAmount.toFixed(2)}g, å¯†åº¦:${avgDensity})`;
            container.appendChild(sizeInfo);

            // æ’å‡ºå¾…ã¡ã‚¨ãƒªã‚¢ã®çµ±è¨ˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆTakeã‚¹ãƒ†ãƒƒãƒ—æ™‚ã®ã¿è¡¨ç¤ºï¼‰
            if (subState.pending && subState.pending.size > 0) {
                // Takeã‚¨ãƒªã‚¢ã®ä½ç½®ã‚’è¨ˆç®—
                let takeAreaLeft = 0;
                const totalUsedSize = subState.keeps.reduce((sum, keep) => sum + keep.size, 0) + subState.current.size + (subState.room?.size || 0);
                takeAreaLeft = (totalUsedSize / subState.maxSize) * 100;
                const takeAreaWidth = (subState.pending.size / subState.maxSize) * 100;

                const takeOverlay = document.createElement('div');
                takeOverlay.className = 'take-stats-overlay';
                takeOverlay.style.position = 'absolute';
                takeOverlay.style.top = '100%';
                takeOverlay.style.left = `${takeAreaLeft + takeAreaWidth / 2}%`;
                takeOverlay.style.transform = 'translateX(-50%)';
                takeOverlay.style.backgroundColor = 'rgba(40, 167, 69, 0.95)';
                takeOverlay.style.color = 'white';
                takeOverlay.style.padding = '3px 8px';
                takeOverlay.style.fontSize = '9px';
                takeOverlay.style.fontWeight = 'bold';
                takeOverlay.style.borderRadius = '8px';
                takeOverlay.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';
                takeOverlay.style.zIndex = '1000';
                takeOverlay.style.textAlign = 'center';
                takeOverlay.style.whiteSpace = 'nowrap';
                takeOverlay.style.minWidth = 'fit-content';

                takeOverlay.textContent = `ğŸ“¤ ${subState.pending.amount.toFixed(3)}g`;

                container.appendChild(takeOverlay);
            }

            return container;
        }

        function renderState(state) {
            console.log('renderState called with state:', state);
            const containers = document.querySelectorAll('.sub-container');
            containers.forEach((container, index) => {
                if (state.subs[index]) {
                    console.log(`Rendering sub${index}:`, state.subs[index]);
                    const paintSection = container.querySelector('.paint-section');
                    if (paintSection) {
                        paintSection.innerHTML = '';
                        paintSection.style.border = '2px solid #000';
                        paintSection.style.borderRadius = '4px';
                        const renderedSub = renderSubState(state.subs[index]);
                        paintSection.appendChild(renderedSub);
                    } else {
                        console.warn(`paint-section not found for sub${index}`, container);
                    }
                }
            });

            // ãƒ’ãƒ³ãƒˆã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ›´æ–°
            const stepCounter = document.querySelector('#recipeStepCounter');
            if (stepCounter) {
                stepCounter.textContent = `${currentStateIndex + 1} / ${allStates.length}`;
            }

            const stepContent = document.querySelector('#recipeStepContent');
            if (stepContent && state.hint) {
                stepContent.innerHTML = `
                    <div class="step-info">
                        <div class="step-hint">${state.hint}</div>
                        <div class="step-message">${state.message}</div>
                    </div>
                `;
            }

            // è‰²ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–°
            updateColorPreview(state);
        }

        function updateColorPreview(state) {
            console.log('updateColorPreview called with state:', state);
            let colorPreviewSection = document.querySelector('.color-preview-section');
            if (!colorPreviewSection) {
                colorPreviewSection = document.createElement('div');
                colorPreviewSection.className = 'color-preview-section';

                const recipeVisualizer = document.querySelector('.recipe-visualizer');
                if (recipeVisualizer) {
                    recipeVisualizer.appendChild(colorPreviewSection);
                    console.log('Color preview section created and added');
                } else {
                    console.warn('Recipe visualizer not found');
                    return;
                }
            }

            try {
                const targetCMY = calculateTargetColor();
                const submittedCMY = calculateSubmittedColor(state);

                console.log('Target CMY:', targetCMY);
                console.log('Submitted CMY:', submittedCMY);
                console.log('Submitted colors count:', state ? state.submittedColors.length : 0);

                // CMYã‹ã‚‰RGBã«å¤‰æ›
                const targetRGB = cmyToRgb(targetCMY[0], targetCMY[1], targetCMY[2]);

                let submittedDisplay, distanceDisplay;

                if (submittedCMY === null) {
                    // æœªæ’å‡ºã®å ´åˆ
                    submittedDisplay = {
                        rgb: [255, 255, 255], // ç™½èƒŒæ™¯
                        cmy: [0, 0, 0],
                        label: 'æœªæ’å‡º',
                        info: 'ã¾ã æ’å‡ºã•ã‚Œã¦ã„ã¾ã›ã‚“'
                    };
                    distanceDisplay = {
                        value: '---',
                        label: 'æ’å‡ºå¾Œã«è¨ˆç®—ã•ã‚Œã¾ã™'
                    };
                } else {
                    // æ’å‡ºæ¸ˆã¿ã®å ´åˆ
                    const submittedRGB = cmyToRgb(submittedCMY[0], submittedCMY[1], submittedCMY[2]);
                    const distance = calculateColorDistance(targetCMY, submittedCMY);

                    submittedDisplay = {
                        rgb: submittedRGB,
                        cmy: submittedCMY,
                        label: 'å®Ÿéš›',
                        info: `CMY: [${submittedCMY[0].toFixed(3)}, ${submittedCMY[1].toFixed(3)}, ${submittedCMY[2].toFixed(3)}]`
                    };
                    distanceDisplay = {
                        value: distance.toFixed(6),
                        label: 'ãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰è·é›¢ï¼ˆCMYç©ºé–“ã§ã®èª¤å·®ï¼‰'
                    };
                }

                console.log('Target RGB:', targetRGB);
                console.log('Submitted display:', submittedDisplay);

                colorPreviewSection.innerHTML = `
                    <div class="color-preview-title">è‰²èª¿åˆçµæœ</div>
                    <div class="color-comparison">
                        <div class="color-sample">
                            <div class="color-sample-title">ç›®æ¨™è‰²</div>
                            <div class="color-box" style="background-color: rgb(${targetRGB[0]}, ${targetRGB[1]}, ${targetRGB[2]});">
                                ç›®æ¨™
                            </div>
                            <div class="color-info">
                                CMY: [${targetCMY[0].toFixed(3)}, ${targetCMY[1].toFixed(3)}, ${targetCMY[2].toFixed(3)}]
                            </div>
                        </div>
                        <div class="color-sample">
                            <div class="color-sample-title">ãƒ¡ã‚¤ãƒ³èª¿åˆã‚¨ãƒªã‚¢</div>
                            <div class="color-box" style="background-color: rgb(${submittedDisplay.rgb[0]}, ${submittedDisplay.rgb[1]}, ${submittedDisplay.rgb[2]}); ${submittedCMY === null ? 'color: black; text-shadow: none;' : ''}">
                                ${submittedDisplay.label}
                            </div>
                            <div class="color-info">
                                ${submittedDisplay.info}
                            </div>
                        </div>
                    </div>
                    <div class="error-display">
                        <div class="error-value">${distanceDisplay.value}</div>
                        <div class="error-label">${distanceDisplay.label}</div>
                    </div>
                `;
            } catch (error) {
                console.error('Error in updateColorPreview:', error);
                colorPreviewSection.innerHTML = `<div class="color-preview-title">è‰²èª¿åˆçµæœ (ã‚¨ãƒ©ãƒ¼)</div><div style="color: red;">ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}</div>`;
            }
        }

        /* HSLè‰²ã‚’RGBã«å¤‰æ› */
        function hexToRgb(color) {
            if (color.startsWith('hsl')) {
                const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (match) {
                    const h = parseInt(match[1]) / 360;
                    const s = parseInt(match[2]) / 100;
                    const l = parseInt(match[3]) / 100;

                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;

                    return {
                        r: Math.round(hue2rgb(p, q, h + 1 / 3) * 255),
                        g: Math.round(hue2rgb(p, q, h) * 255),
                        b: Math.round(hue2rgb(p, q, h - 1 / 3) * 255)
                    };
                }
            }
            return { r: 128, g: 128, b: 128 }; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
        }

        /* HSLã‹ã‚‰CMYã¸ã®å¤‰æ› */
        function hslToCmy(hslColor) {
            // HSLæ–‡å­—åˆ—ã‹ã‚‰å€¤ã‚’æŠ½å‡º
            const match = hslColor.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
            if (!match) return [0, 0, 0];

            const h = parseInt(match[1]) / 360;
            const s = parseInt(match[2]) / 100;
            const l = parseInt(match[3]) / 100;

            // HSLã‹ã‚‰RGBã«å¤‰æ›
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;

            const r = hue2rgb(p, q, h + 1 / 3);
            const g = hue2rgb(p, q, h);
            const b = hue2rgb(p, q, h - 1 / 3);

            // RGBã‹ã‚‰CMYã«å¤‰æ›
            const c = 1 - r;
            const m = 1 - g;
            const y = 1 - b;

            return [c, m, y];
        }

        /* ç¾åœ¨ã®ãƒ•ã‚§ãƒ¼ã‚ºã‹ã‚‰ç›®æ¨™èª¿åˆæ¯”ã‚’æŠ½å‡º */
        function extractTargetBlendRatio() {
            if (!phases[current]) {
                console.error('Current phase not found');
                return [];
            }

            const bodyText = phases[current].body;
            console.log('Extracting target blend ratio from phase:', phases[current].label);

            // "æ–¹ç¨‹å¼ã‚’è§£ãï¼ˆã‚¬ã‚¦ã‚¹æ¶ˆå»æ³•ï¼‰ã“ã¨ã§èª¿åˆæ¯”ãŒ" ã®å¾Œã®è¡Œã‹ã‚‰æ•°å€¤é…åˆ—ã‚’æ¢ã™
            const lines = bodyText.split('\n');
            let foundTrigger = false;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                if (line.includes('æ–¹ç¨‹å¼ã‚’è§£ãï¼ˆã‚¬ã‚¦ã‚¹æ¶ˆå»æ³•ï¼‰ã“ã¨ã§èª¿åˆæ¯”ãŒ')) {
                    foundTrigger = true;
                    console.log('Found trigger line:', line);
                    continue;
                }

                if (foundTrigger && line.match(/^#\s*\[[0-9.\s]+\]$/)) {
                    // æ¬¡ã®è¡Œã§æ•°å€¤é…åˆ—ã‚’ç™ºè¦‹
                    const arrayMatch = line.match(/\[([0-9.\s]+)\]/);
                    if (arrayMatch) {
                        const ratioString = arrayMatch[1];
                        const ratios = ratioString.split(/\s+/).map(s => parseFloat(s)).filter(n => !isNaN(n));
                        console.log('Found target blend ratio:', ratios);
                        return ratios;
                    }
                }
            }

            console.warn('Target blend ratio not found in current phase');
            return [];
        }

        /* ç›®æ¨™è‰²ã®è¨ˆç®— */
        function calculateTargetColor() {
            console.log('calculateTargetColor called');

            const targetBlendRatio = extractTargetBlendRatio();
            console.log('baseColors:', baseColors);
            console.log('targetBlendRatio:', targetBlendRatio);

            if (!baseColors || baseColors.length === 0) {
                console.error('Base colors not found');
                return [0, 0, 0];
            }

            if (!targetBlendRatio || targetBlendRatio.length === 0) {
                console.error('Target blend ratio not found');
                return [0, 0, 0];
            }

            let targetCMY = [0, 0, 0]; // [C, M, Y]
            let totalRatio = 0;

            baseColors.forEach((color, index) => {
                if (index < targetBlendRatio.length) {
                    const cmy = hslToCmy(color);
                    const ratio = targetBlendRatio[index];

                    console.log(`sub${index} HSL: ${color} -> CMY: [${cmy[0].toFixed(3)}, ${cmy[1].toFixed(3)}, ${cmy[2].toFixed(3)}], ratio: ${ratio}`);

                    targetCMY[0] += cmy[0] * ratio;
                    targetCMY[1] += cmy[1] * ratio;
                    targetCMY[2] += cmy[2] * ratio;
                    totalRatio += ratio;
                }
            });

            console.log('Before normalization - targetCMY:', targetCMY, 'totalRatio:', totalRatio);

            // æ­£è¦åŒ–
            if (totalRatio > 0) {
                targetCMY[0] /= totalRatio;
                targetCMY[1] /= totalRatio;
                targetCMY[2] /= totalRatio;
            }

            console.log('Final targetCMY:', targetCMY);
            return targetCMY;
        }

        /* æ’å‡ºæ¸ˆã¿è‰²ã®ç´¯ç©è¨ˆç®— */
        function calculateSubmittedColor(state) {
            const submittedColors = state ? state.submittedColors : [];
            console.log('calculateSubmittedColor called, submittedColors.length:', submittedColors.length);

            // æ’å‡ºãŒãªã„å ´åˆã¯nullã‚’è¿”ã™
            if (submittedColors.length === 0) {
                console.log('No submitted colors, returning null');
                return null;
            }

            let submittedCMY = [0, 0, 0]; // [C, M, Y]
            let totalAmount = 0;

            submittedColors.forEach(color => {
                submittedCMY[0] += color.cmy[0] * color.amount;
                submittedCMY[1] += color.cmy[1] * color.amount;
                submittedCMY[2] += color.cmy[2] * color.amount;
                totalAmount += color.amount;
            });

            // åŠ é‡å¹³å‡
            if (totalAmount > 0) {
                submittedCMY[0] /= totalAmount;
                submittedCMY[1] /= totalAmount;
                submittedCMY[2] /= totalAmount;
            }

            console.log('Calculated submitted CMY:', submittedCMY);
            return submittedCMY;
        }

        /* ãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰è·é›¢è¨ˆç®— */
        function calculateColorDistance(cmy1, cmy2) {
            const dc = cmy1[0] - cmy2[0];
            const dm = cmy1[1] - cmy2[1];
            const dy = cmy1[2] - cmy2[2];
            return Math.sqrt(dc * dc + dm * dm + dy * dy);
        }

        /* å…¨ã‚¹ãƒ†ãƒƒãƒ—ã®Stateäº‹å‰è¨ˆç®— */
        function computeAllStates() {
            allStates = [];

            // åˆæœŸçŠ¶æ…‹ã‚’ä½œæˆ
            const initialState = createInitialState();
            allStates.push(initialState);

            // å„ãƒ¬ã‚·ãƒ”ã‚¹ãƒ†ãƒƒãƒ—ã‚’å‡¦ç†
            const allSteps = [];
            recipeSteps.forEach((recipe, recipeIndex) => {
                recipe.steps.forEach((stepText, stepIndex) => {
                    allSteps.push({
                        sub: recipe.sub,
                        step: stepText
                    });
                });
            });

            // å„ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã«çŠ¶æ…‹ã‚’è¨ˆç®—
            for (let i = 0; i < allSteps.length; i++) {
                const previousState = allStates[allStates.length - 1];
                const newState = computeNextState(previousState, allSteps[i], i + 1);
                allStates.push(newState);
            }
        }

        function createInitialState() {
            const state = new State(0, 'åˆæœŸçŠ¶æ…‹', 'å„subã‚¨ãƒªã‚¢ã®åˆæœŸè¨­å®š');

            // å„subã®åˆæœŸçŠ¶æ…‹ã‚’ä½œæˆ
            const subLines = phases[current].body.split('\n').filter(l => /^\[sub\d+\]/.test(l));
            subLines.forEach((line, index) => {
                const size = parseInt(line.match(/size:\s*(\d+)/)[1]);
                const amount = parseFloat(line.match(/amount:\s*([0-9.]+)/)[1]);

                const subState = new SubState(index, baseColors[index] || '#888', globalMax);
                subState.current = new Area(size, amount);
                subState.updateEmpty();
                state.subs.push(subState);
            });

            return state;
        }

        function computeNextState(previousState, step, stepIndex) {
            // å‰ã®çŠ¶æ…‹ã‚’ã‚³ãƒ”ãƒ¼
            const newState = cloneState(previousState);
            newState.stepIndex = stepIndex;

            const subId = step.sub.id;
            const subState = newState.subs[subId];
            if (!subState) return newState;

            // ã‚¹ãƒ†ãƒƒãƒ—ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®šã—ã¦å‡¦ç†
            if (step.step.includes('ãƒãƒ¥ãƒ¼ãƒ–ã‹ã‚‰è£œå……')) {
                newState.hint = `sub${subId} (ç›®æ¨™: ${step.sub.target})`;
                newState.message = `ğŸ’§ ãƒãƒ¥ãƒ¼ãƒ–ã‹ã‚‰1.0gè£œå……`;
                subState.current.amount += 1.0;

            } else if (step.step.includes('æ–°ã—ã„ä½ç½®ã«ä»•åˆ‡ã‚Šã‚’è¨­ç½®') || step.step.includes('ã‚­ãƒ¼ãƒ—ç”¨ä»•åˆ‡ã‚Šã‚’è¨­ç½®')) {
                newState.hint = `sub${subId} ã‚­ãƒ¼ãƒ—ä»•åˆ‡ã‚Šè¨­ç½®`;
                newState.message = `ğŸš§ ã‚­ãƒ¼ãƒ—ã‚¨ãƒªã‚¢ã‚’ç¢ºä¿`;

                const context = getStepContextFromRecipe(subId);
                console.log(`Step: ${step.step}, subId: ${subId}, context:`, context);
                if (context.keepSize) {
                    const keepSize = context.keepSize;
                    const useSize = subState.current.size - keepSize;
                    const totalAmount = subState.current.amount;

                    console.log(`ã‚­ãƒ¼ãƒ—è¨­ç½®: keepSize=${keepSize}, useSize=${useSize}, totalAmount=${totalAmount}`);

                    // ã‚­ãƒ¼ãƒ—ã¨ä½¿ç”¨éƒ¨åˆ†ã«åˆ†å‰²
                    const keepAmount = totalAmount * (keepSize / subState.current.size);
                    const useAmount = totalAmount * (useSize / subState.current.size);

                    subState.keeps.push(new Area(keepSize, keepAmount));
                    subState.current = new Area(useSize, useAmount);

                    console.log('åˆ†å‰²å¾Œ - keeps:', subState.keeps, 'current:', subState.current);
                } else {
                    console.log('context.keepSize not found!');
                }

            } else if (step.step.includes('æ‹¡å¼µå…ˆã«æ–°ã—ã„ä»•åˆ‡ã‚Šã‚’è¨­ç½®')) {
                newState.hint = `sub${subId} æ‹¡å¼µä»•åˆ‡ã‚Šè¨­ç½®`;
                newState.message = `ğŸš§ æ‹¡å¼µå…ˆã®ä»•åˆ‡ã‚Šã‚’æº–å‚™`;

                const context = getStepContextFromRecipe(subId);
                if (context.expandSize) {
                    subState.room = new Area(context.expandSize, 0);
                }

            } else if (step.step.includes('å…ƒã®ä»•åˆ‡ã‚Šã‚’è§£é™¤ã—ã¦ã‚¤ãƒ³ã‚¯ãŒæµå‹•')) {
                newState.hint = `sub${subId} ä»•åˆ‡ã‚Šè§£é™¤ãƒ»æµå‹•`;
                newState.message = `ğŸ”“ ä»•åˆ‡ã‚Šè§£é™¤ã—ã¦ã‚¤ãƒ³ã‚¯ãŒæµå‹•`;

                if (subState.room) {
                    // æ‹¡å¼µï¼šroomã¨çµ±åˆï¼ˆamountã¯å¤‰ã‚ã‚‰ãšã€sizeãŒå¢—ãˆã¦å¯†åº¦ãŒè–„ããªã‚‹ï¼‰
                    const newSize = subState.current.size + subState.room.size;
                    const currentAmount = subState.current.amount; // çµµå…·é‡ã¯å¤‰ã‚ã‚‰ãªã„
                    subState.current = new Area(newSize, currentAmount);
                    subState.room = null;
                }

            } else if (step.step.includes('å…ƒã®ä»•åˆ‡ã‚Šã‚’è§£é™¤ã—ã¦') && step.step.includes('ãƒã‚¹åˆ†æµã‚Œè¾¼ã¿')) {
                newState.hint = `sub${subId} æ‹¡å¼µå®Œäº†`;
                newState.message = `ğŸŒŠ ä»•åˆ‡ã‚Šè§£é™¤ã—ã¦ã‚¤ãƒ³ã‚¯ãŒæµã‚Œè¾¼ã¿æ‹¡å¼µå®Œäº†`;

                if (subState.room) {
                    // æ‹¡å¼µï¼šroomã¨çµ±åˆï¼ˆamountã¯å¤‰ã‚ã‚‰ãšã€sizeãŒå¢—ãˆã¦å¯†åº¦ãŒè–„ããªã‚‹ï¼‰
                    const newSize = subState.current.size + subState.room.size;
                    const currentAmount = subState.current.amount; // çµµå…·é‡ã¯å¤‰ã‚ã‚‰ãªã„
                    subState.current = new Area(newSize, currentAmount);
                    subState.room = null;
                }

            } else if (step.step.includes('å³ã‹ã‚‰') && step.step.includes('ä½ç½®ã«ä»•åˆ‡ã‚Šã‚’è¨­ç½®')) {
                newState.hint = `sub${subId} æ’å‡ºä»•åˆ‡ã‚Šè¨­ç½®`;
                newState.message = `âœ‚ï¸ æ’å‡ºã‚¨ãƒªã‚¢ã‚’åˆ†é›¢`;

                const context = getStepContextFromRecipe(subId);
                if (context.takeSize) {
                    const takeSize = context.takeSize;
                    const remainSize = subState.current.size - takeSize;
                    const totalAmount = subState.current.amount;

                    // å…ƒã®currentã‚’sizeæ¯”ã§åˆ†å‰²
                    const remainAmount = totalAmount * (remainSize / subState.current.size);
                    const takeAmount = totalAmount * (takeSize / subState.current.size);

                    subState.current = new Area(remainSize, remainAmount);
                    // æ’å‡ºéƒ¨åˆ†ã¯ pending ã¨ã—ã¦ä¿å­˜
                    subState.pending = new Area(takeSize, takeAmount);
                }

            } else if (step.step.includes('ä»•åˆ‡ã‚Šè§£é™¤ã—ã¦ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ã«æ’å‡º')) {
                newState.hint = `sub${subId} æ’å‡ºå®Œäº†`;
                newState.message = `ğŸ“¤ ä»•åˆ‡ã‚Šè§£é™¤ã—ã¦ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ã«æ’å‡º`;

                // æ’å‡ºè‰²ã‚’è¨˜éŒ²ï¼ˆbaseColorsã‹ã‚‰å–å¾—ï¼‰
                if (subState.pending && baseColors[subId]) {
                    const cmy = hslToCmy(baseColors[subId]);
                    const submittedColor = {
                        sub: subId,
                        amount: subState.pending.amount,
                        cmy: cmy
                    };
                    newState.submittedColors.push(submittedColor);
                    console.log(`Added submitted color for sub${subId}:`, submittedColor);
                }

                // pendingéƒ¨åˆ†ã‚’å‰Šé™¤ï¼ˆæ’å‡ºï¼‰
                subState.pending = null;
            }

            subState.updateEmpty();
            return newState;
        }

        function cloneState(state) {
            const newState = new State(state.stepIndex, state.hint, state.message);
            // æ’å‡ºè‰²å±¥æ­´ã‚‚ã‚³ãƒ”ãƒ¼
            newState.submittedColors = [...state.submittedColors];

            state.subs.forEach(sub => {
                const newSub = new SubState(sub.id, sub.color, sub.maxSize);
                newSub.keeps = sub.keeps.map(keep => new Area(keep.size, keep.amount));
                newSub.current = new Area(sub.current.size, sub.current.amount);
                newSub.room = sub.room ? new Area(sub.room.size, sub.room.amount) : null;
                newSub.pending = sub.pending ? new Area(sub.pending.size, sub.pending.amount) : null;
                newSub.empty = new Area(sub.empty.size, sub.empty.amount);
                newState.subs.push(newSub);
            });
            return newState;
        }

        function getStepContextFromRecipe(subId) {
            const context = {};

            // è©²å½“ã™ã‚‹subã®ãƒ¬ã‚·ãƒ”ã‚’æ¤œç´¢
            const recipe = recipeSteps.find(r => r.sub.id === subId);
            if (!recipe) {
                console.log(`Recipe not found for subId: ${subId}`);
                return context;
            }

            console.log(`Found recipe for sub${subId}:`, recipe);

            // å…ƒã®ãƒ¬ã‚·ãƒ”ãƒ†ã‚­ã‚¹ãƒˆï¼ˆHTMLï¼‰ã‹ã‚‰ç›´æ¥æ•°å€¤ã‚’æŠ½å‡ºã™ã‚‹
            const bodyText = phases[current].body;
            const lines = bodyText.split('\n');

            // sub0ã®ãƒ¬ã‚·ãƒ”ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ¢ã™
            const subRecipeStart = lines.findIndex(l => l.includes(`sub${subId}ã®ãƒ¬ã‚·ãƒ”`));
            if (subRecipeStart === -1) {
                console.log(`Recipe section not found for sub${subId}`);
                return context;
            }

            // æ¬¡ã®subãƒ¬ã‚·ãƒ”ã¾ã§ã®ç¯„å›²ã‚’å–å¾—
            const nextSubIndex = lines.findIndex((l, index) =>
                index > subRecipeStart && l.includes('ã®ãƒ¬ã‚·ãƒ”(ç›®æ¨™èª¿åˆæ¯”')
            );
            const subRecipeEnd = nextSubIndex === -1 ? lines.length : nextSubIndex;
            const subRecipeLines = lines.slice(subRecipeStart, subRecipeEnd);

            console.log(`Sub${subId} recipe lines:`, subRecipeLines);

            // å„ãƒ¬ã‚·ãƒ”è¡Œã‹ã‚‰æ•°å€¤ã‚’æŠ½å‡º
            subRecipeLines.forEach(line => {
                console.log(`Checking recipe line: "${line}"`);
                if (line.includes('ãƒã‚¹ã‚’ã‚­ãƒ¼ãƒ—')) {
                    const match = line.match(/(\d+)ãƒã‚¹ã‚’ã‚­ãƒ¼ãƒ—/);
                    if (match) {
                        context.keepSize = parseInt(match[1]);
                        console.log(`Found keepSize: ${context.keepSize}`);
                    }
                }
                if (line.includes('ãƒã‚¹æ‹¡å¼µ')) {
                    const expandMatch = line.match(/(\d+)ãƒã‚¹æ‹¡å¼µ.*?(\d+)ãƒã‚¹ã«/);
                    if (expandMatch) {
                        context.expandSize = parseInt(expandMatch[1]);
                        context.newSize = parseInt(expandMatch[2]);
                        console.log(`Found expansion: ${context.expandSize} -> ${context.newSize}`);
                    }
                }
                if (line.includes('ãƒã‚¹å–ã‚Š')) {
                    const match = line.match(/(\d+)ãƒã‚¹å–ã‚Š/);
                    if (match) {
                        context.takeSize = parseInt(match[1]);
                        console.log(`Found takeSize: ${context.takeSize}`);
                    }
                }
            });

            console.log(`Final context for sub${subId}:`, context);
            return context;
        }




        function render() {
            const viz = document.getElementById('visualization');
            const com = document.getElementById('comments');
            viz.innerHTML = '';
            com.innerHTML = '';
            document.getElementById('phaseLabel').textContent = phases[current].label;

            // ãƒ•ã‚§ãƒ¼ã‚ºå¤‰æ›´ã®è¿½è·¡ï¼ˆæ’å‡ºè‰²å±¥æ­´ã¯å„Stateã«å«ã¾ã‚Œã‚‹ãŸã‚ã‚¯ãƒªã‚¢ä¸è¦ï¼‰
            if (window.lastPhaseIndex !== current) {
                console.log('Phase changed to:', current);
                window.lastPhaseIndex = current;
            }

            const lines = phases[current].body.split('\n');

            /* ã‚³ãƒ¡ãƒ³ãƒˆè¡¨ç¤ºï¼š# ã‚’é™¤ã */
            lines.filter(l => l.trim().startsWith('#')).forEach(l => {
                const p = document.createElement('p');
                const txt = l.replace(/^#\s*/, '');
                // ç©ºè¡Œä¿æŒç”¨ã« nbsp
                p.innerHTML = (txt === '' ? '&nbsp;' :
                    txt.replace(/(ã‚­ãƒ¼ãƒ—|æ‹¡å¼µ|æœ€é©ãªãƒ¬ã‚·ãƒ”)/g,
                        '<span class="keyword">$1</span>'));
                com.appendChild(p);
            });

            // æœ€é©ãªãƒ¬ã‚·ãƒ”ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹å ´åˆã¯æ–°ã—ã„ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ã‚’è¡¨ç¤º
            const bodyText = phases[current].body;
            if (bodyText.includes('ã€‡æœ€é©ãªãƒ¬ã‚·ãƒ”')) {
                recipeSteps = parseRecipe(bodyText);
                currentRecipeStep = 0;
                if (recipeSteps.length > 0) {
                    createRecipeVisualizer();
                    // æ–°ã—ã„Stateè¨ˆç®—ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–
                    setTimeout(() => {
                        console.log('recipeSteps:', recipeSteps);
                        computeAllStates();
                        console.log('allStates.length:', allStates.length);
                        if (allStates.length > 0) {
                            currentStateIndex = 0;
                            renderState(allStates[0]);
                            updateRecipeNavigation();
                        } else {
                            console.error('allStatesãŒç©ºã§ã™');
                        }
                    }, 100);
                    return; // ãƒ¬ã‚·ãƒ”ãŒã‚ã‚‹å ´åˆã¯å¾“æ¥ã®è¡¨ç¤ºã‚’ã‚¹ã‚­ãƒƒãƒ—
                }
            }

            /* å¾“æ¥ã®è¡¨ç¤ºï¼ˆãƒ¬ã‚·ãƒ”ãŒãªã„å ´åˆã®ã¿ï¼‰ */
            const title = document.createElement('div');
            title.className = 'visualizer-title';
            title.textContent = `ç¾åœ¨ã®çŠ¶æ…‹`;
            viz.appendChild(title);
            const mainLine = lines.find(l => /^\[main\]/.test(l));
            if (mainLine) {
                const size = mainLine.match(/size:\s*(\d+)/)[1];
                const amount = mainLine.match(/amount:\s*([0-9.]+)/)[1];
                const cmys = mainLine.match(/CMY:\s*\[([^\]]+)\]/)[1];
                const mv = document.createElement('div');
                mv.className = 'main-value';
                mv.textContent = `main  size: ${size}, amount: ${amount}`;
                const mv2 = document.createElement('div');
                mv2.className = 'main-value';
                mv2.textContent = `main  CMY: [${cmys}]`;
                viz.appendChild(mv);
                viz.appendChild(mv2);
            }

            /* subs */
            lines.filter(l => /^\[sub\d+\]/.test(l)).forEach(l => {
                const size = parseInt(l.match(/size:\s*(\d+)/)[1]);
                const amount = l.match(/amount:\s*([0-9.]+)/)[1];
                const cmyMatch = l.match(/CMY:\s*\[([0-9eE+\-.]+) ([0-9eE+\-.]+) ([0-9eE+\-.]+)\]/);
                const c = parseFloat(cmyMatch[1]);
                const m = parseFloat(cmyMatch[2]);
                const y = parseFloat(cmyMatch[3]);
                const [r, g, b] = cmyToRgb(c, m, y);

                // ãƒ©ãƒƒãƒ‘ãƒ¼
                const wrapper = document.createElement('div');
                wrapper.className = 'bar-wrapper';

                // amount + CMY
                const labelTop = document.createElement('div');
                labelTop.className = 'amountCMY';
                labelTop.textContent = `amount: ${amount}, CMY: [${c.toFixed(3)} ${m.toFixed(3)} ${y.toFixed(3)}]`;
                wrapper.appendChild(labelTop);

                // è¡Œ (ãƒãƒ¼ + size)
                const row = document.createElement('div');
                row.className = 'row';

                const bar = document.createElement('div');
                bar.className = 'item';
                bar.style.width = ((size / globalMax) * 100) + '%';
                if (!(c === 0 && m === 0 && y === 0)) {
                    bar.style.backgroundColor = `rgb(${r},${g},${b})`;
                    bar.style.color = textColorForBg(r, g, b);
                } else {
                    bar.style.backgroundColor = '#5c95c5';
                }

                const sizeLbl = document.createElement('span');
                sizeLbl.className = 'size-label';
                sizeLbl.textContent = `size: ${size}`;

                row.appendChild(bar);
                row.appendChild(sizeLbl);
                wrapper.appendChild(row);
                viz.appendChild(wrapper);
            });
        }

        /* ãƒŠãƒ“ */
        document.getElementById('firstBtn').onclick = () => { current = 0; render(); };
        document.getElementById('lastBtn').onclick = () => { current = phases.length - 1; render(); };
        document.getElementById('prevBtn').onclick = () => { if (current > 0) { current--; render(); } };
        document.getElementById('nextBtn').onclick = () => { if (current < phases.length - 1) { current++; render(); } };

        /* ãƒ¬ã‚·ãƒ”ã‚¹ãƒ†ãƒƒãƒ—ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ */
        function prevRecipeStep() {
            if (currentStateIndex > 0) {
                currentStateIndex--;
                renderState(allStates[currentStateIndex]);
                updateRecipeNavigation();
            }
        }

        function nextRecipeStep() {
            if (currentStateIndex < allStates.length - 1) {
                currentStateIndex++;
                renderState(allStates[currentStateIndex]);
                updateRecipeNavigation();
            }
        }

        function updateRecipeNavigation() {
            const prevBtn = document.querySelector('.recipe-nav .prev-btn');
            const nextBtn = document.querySelector('.recipe-nav .next-btn');
            const stepCounter = document.querySelector('.step-counter');

            if (prevBtn) prevBtn.disabled = currentStateIndex === 0;
            if (nextBtn) nextBtn.disabled = currentStateIndex === allStates.length - 1;
            if (stepCounter) stepCounter.textContent = `${currentStateIndex + 1} / ${allStates.length}`;
        }
    </script>
</body>

</html>
